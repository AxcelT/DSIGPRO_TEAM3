import os
import librosa
import numpy as np
import matplotlib.pyplot as plt
import soundfile as sf

# Helper Function: Log Messages
def log_message(message):
    """Log messages for debugging and updates."""
    print(f"[INFO] {message}")

# Step 1: Data Preprocessing
def preprocess_audio(file_path):
    """Load audio file (no resampling or conversion)."""
    log_message(f"Loading audio file: {file_path}")
    audio, sr = librosa.load(file_path, sr=None, mono=True)  # Load audio with original sampling rate
    log_message(f"Sample Rate: {sr}")
    log_message(f"Duration: {len(audio) / sr:.2f} seconds")
    return audio, sr

# Step 2: Short Segment Detection
def detect_short_segments(audio, sr, energy_threshold=0.02, min_duration=0.3, max_duration=2.0):
    """Detect short speech segments based on energy."""
    log_message("Detecting short speech segments...")
    energy = np.square(audio)  # Calculate energy
    segment_indices = []
    start = None

    for i, e in enumerate(energy):
        if e > energy_threshold:
            if start is None:
                start = i
        elif start is not None:
            end = i
            duration = (end - start) / sr
            if min_duration <= duration <= max_duration:
                segment_indices.append((start / sr, end / sr))
            start = None

    if start is not None:  # Handle last segment
        end = len(energy)
        duration = (end - start) / sr
        if min_duration <= duration <= max_duration:
            segment_indices.append((start / sr, end / sr))

    log_message(f"Detected {len(segment_indices)} valid segments.")
    return segment_indices

# Step 3: Save Detected Segments
def save_segments(audio, sr, segments, output_dir, base_filename):
    """Save each detected segment as a separate audio file."""
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    log_message(f"Saving detected segments to '{output_dir}'...")
    for i, (start, end) in enumerate(segments, 1):
        segment = audio[int(start * sr):int(end * sr)]
        output_path = os.path.join(output_dir, f"{base_filename}_segment_{i}.wav")
        sf.write(output_path, segment, sr)
        log_message(f"Segment saved: {output_path} ({start:.2f}s - {end:.2f}s)")

# Step 4: Generate Subtitles
def generate_subtitles(segments, output_path):
    """Generate subtitle file in .srt format for detected segments."""
    log_message("Generating subtitles...")
    with open(output_path, "w") as subtitle_file:
        for i, (start, end) in enumerate(segments, 1):
            start_time = format_time(start)
            end_time = format_time(end)
            subtitle_file.write(f"{i}\n{start_time} --> {end_time}\n[Segment {i}]\n\n")
    log_message(f"Subtitles saved: {output_path}")

def format_time(seconds):
    """Format time in seconds to SRT time format (hh:mm:ss,ms)."""
    millis = int((seconds - int(seconds)) * 1000)
    seconds = int(seconds)
    minutes = seconds // 60
    seconds = seconds % 60
    hours = minutes // 60
    minutes = minutes % 60
    return f"{hours:02}:{minutes:02}:{seconds:02},{millis:03}"

# Step 5: Plot Energy Curve
def plot_energy(audio, sr, segments, output_path):
    """Plot energy curve with detected segments highlighted."""
    log_message("Plotting energy curve with detected segments...")
    energy = np.square(audio)
    times = np.arange(len(energy)) / sr
    plt.figure(figsize=(12, 6))
    plt.plot(times, energy, label="Energy")
    for start, end in segments:
        plt.axvspan(start, end, color="red", alpha=0.3, label="Detected Segment")
    plt.title("Energy Curve with Detected Short Segments")
    plt.xlabel("Time (s)")
    plt.ylabel("Energy")
    plt.legend()
    plt.savefig(output_path)
    log_message(f"Energy curve saved: {output_path}")

# Main Function
if __name__ == "__main__":
    input_audio = r"audio\Frasier1.wav"
    base_output_dir = r"D:\School\DSIGPRO_Project"

    # Output directories
    base_filename = os.path.splitext(os.path.basename(input_audio))[0]
    segments_dir = os.path.join(base_output_dir, "segments")
    subtitles_dir = os.path.join(base_output_dir, "subtitles")
    plots_dir = os.path.join(base_output_dir, "plots")

    # Ensure output directories exist
    os.makedirs(segments_dir, exist_ok=True)
    os.makedirs(subtitles_dir, exist_ok=True)
    os.makedirs(plots_dir, exist_ok=True)

    # Preprocess audio
    audio, sr = preprocess_audio(input_audio)

    # Detect short segments
    short_segments = detect_short_segments(audio, sr)

    # Save detected segments
    save_segments(audio, sr, short_segments, segments_dir, base_filename)

    # Generate subtitles
    subtitle_file = os.path.join(subtitles_dir, f"{base_filename}_segments.srt")
    generate_subtitles(short_segments, subtitle_file)

    # Plot energy curve
    energy_plot_path = os.path.join(plots_dir, f"{base_filename}_energy_curve.png")
    plot_energy(audio, sr, short_segments, energy_plot_path)

    log_message("Processing completed successfully!")
